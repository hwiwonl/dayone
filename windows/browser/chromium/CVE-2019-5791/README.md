# CVE-2019-5791
* Date : January 2019
* Credit : cwhan.tunz@gmail.com (Google Project Zero)
* PoC was tested on Ubuntu 18.04 and Windows 10 without Sandbox
* Uploaded source code must be tested in ubuntu 18.04 with --allow-natives-syntax option
* On windows 10, shellcode must be changed.

## Description
A lazy-compiled function generates an interpreter code confusing smi value as a heap object. seems like it accesses a function object mutated to smi when generating a call stack.

## Root Cause

자바스크립트는 함수 외부에서 함수 내부의 변수를 참조해 closure로 반환하는 것을 가능하도록 해준다. 이러한 자유로운 특징 때문에 컴파일시에 각 함수마다 참조하는 변수가 무엇인지 확인해서 변수를 스택에 할당할 것인지 힙에 할당할 것인지 결정해야한다. 이는 자바스크립트 코드를 파싱하는 단계에서 수행한다. 아래와 같은 예제 코드에서 var foo2=foo(10)에서 foo 함수 내에 인자로 들어가는 10은 stack에 들어가는게 자연스럽지만, foo 함수가 반환하는 closure에서 참조하기 때문에 heap에 선언되어야 한다. 

```javascript
function foo(d){
  return function foo1(a){
    return a+d;
   };
}

var foo2 = foo(10);

function goo(a){
  return foo2(a);
}

```
또한 자바스크립트는 브라우저에서 끊김없이 수행되어야하기 때문에 모든 함수를 순차적으로 미리 컴파일하지 않고 함수를 잠시 저장해놓고 함수가 처음으로 호출될 때 컴파일을 진행한다. 다만 함수가 아닌 top-level scope에 짜여진 코드는 즉시 컴파일 된다. 즉, v8 엔진이 자바스크립트를 해석하고 구동하는 과정은 다음과 같다. preparser -> parser -> compile -> lazy compile. preparser는 앞서 설명했듯 각 함수가 어떤 변수를 참조하는지에 대한 정보(context)를 반환한다.



## PoC


## Reference

[issue 926651](https://bugs.chromium.org/p/chromium/issues/detail?id=926651)
