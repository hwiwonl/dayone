# Chrome Sealed Frozen Element Kind Type Confusion

## Information
- CVE : None
- 해당 소프트웨어 : Chrome (on Windows)
- 해당 버전 : < Firefox 76.0.3809.132
- 취약점 유형 : TypeConfusion

## Root Cause
### Hidden Class
V8 engine에서 String(or Symbol) Key Object를 생성할때 HiddenClass라는 새로운 class를 생성한다. HiddenClass는 기존 객체지향언어의 Class의 개념과 비슷한데 기존 HiddenClass에 새로운 named Property(String key로 선언된 property)가 추가될때마다 그에 맞는 새로운 HiddenClass를 생성한다. 이를 간략하게 나타낸 그림은 아래와 같다.


![Transitions](/images/writeups/transitions.png)

새로운 객체가 생성될때 해당 객체와 모양이 동일한(string key의 값이 동일한) 기존에 생성된 HC가 있다면 이를 재사용하지만 그렇지 않다면 HiddenClass tree에 새로운 HC를 생성한다. 


![Transition-trees](/images/writeups/transition-trees.png)

small integer key를 가지는 객체의 경우 최적화를 위해 압축된 폼새으로 저장된다. V8은 다양한 element kinds를 관리하는데, 예를들어 PACKED_SMI_ELEMENTS는 앞서 말한 small integer key객체를 저장하는 element kind이다. 저장 포맷은 type confusion을 방지하기 위해 객체가 수정될때마다 변경된다. 예를들어 PACKED_SMI_ELEMENTS 객체에 float key를 가지는 property를 추가하면 element kind가 PACKED_DOUBLE_ELEMENTS로 변경되고 기존의 integer keys도 float형으로 변경된다.

### preventExtensions, seal and freeze
자바스크립트는 object의 properties들을 고정하기 위한 몇가지 방법을 제공한다
- Object.preventExtensions : 새로운 properties가 object에 추가되는 것을 방지한다.
- Object.seal : 세로운 properties의 추가 뿐만아니라 기존의 properties의 재설정을 방지한다.
- Object.freeze : Object.seal의 기능에 더불어서 properties의 값 변경또한 방지한다.

### Root cause
Type Confusion 취약점은 앞서 설명한 세가지 메소드를 호출한 이후 객체를 수정하여 element kind를 변경될때 발생한다. 자세한 설명은 다음장에서 POC살펴보며 분석해보겠다.

## PoC
```javascript
// Based on test/mjsunit/regress/regress-crbug-992914.js
function mainSeal() {
  const a = {foo: 1.1};   // a has map M1
  Object.seal(a);         // a transitions from M1 to M2 Map(HOLEY_SEALED_ELEMENTS)
  const b = {foo: 2.2};   // b has map M1
  Object.preventExtensions(b);  // b transitions from M1 to M3 Map(DICTIONARY_ELEMENTS)
  Object.seal(b);         // b transitions from M3 to M4
  const c = {foo: Object} // c has map M5, which has a tagged `foo` property, causing the maps of `a` and `b` to be deprecated
  b.__proto__ = 0;        // property assignment forces migration of b from deprecated M4 to M6
  a[5] = 1;               // forces migration of a from the deprecated M2 map, v8 incorrectly uses M6 as new map without converting the backing store. M6 has DICTIONARY_ELEMENTS while the backing store remained unconverted.
}
mainSeal();
```

POC에서 a와 b라는 동일한 형태의 두 객체가 생성된다. a의 경우 sea 메소드가 호출되고, b는 seal 메소드와 함께 preventExtensions 메소드가 호출된다. 이 때문에 a의 경우 기존 M1 map에서  HOLEY_SEALED_ELEMENTS라는 element kind로 변경되고 b의 경우 DICTIONARY_ELEMENT로 element kind가 변경된다. 

취약점은 10~13라인에서 발생한다. 10번째 줄에서 객체 c가 이상한 타입의 foo property로 생성된다. 이로인해 foo property를 위한 새로운 map이 생성되고 기존의 a와 b의 map은 deprecated된다. 이로인해 다음번 객체 수정에서 a와 b의 map 형식이 변경된다. 11번째 줄에서는 b의 transition이 발생하고 13번째 줄에서는 a의 transition이 발생한다. 문제는 V8이 a의 map을 b와 동일한 map으로 변경하지만 backing store는 변경하지 못해서 발생한다. 이때문에 FixedArray와 NumberDictionary 간의 Type Confusion이 발생한다. 

위의 예제 말고도 다양한 조합의 type confusion이 발생할 수 있다. 

## How to run exploit?
> OS : Windows 10 64bit
> 
> Chrome version : 76.0.3809.100 and 76.0.3809.132
1) --no-sandbox 옵션으로 크롬 실행
2) exp.html 파일을 로드
3) 쉘코드를 수정하고싶으면 shellcode.js를 수정
## Reference
- [Exodus Intel Blog : "PATCH-GAPPING GOOGLE CHROME"](https://blog.exodusintel.com/2019/09/09/patch-gapping-chrome/)
- [Exodus Intel Github : "Chrome-Issue-992914-Sealed-Frozen-Element-Kind-Type-Confusion-RCE-Exploit"](https://github.com/exodusintel/Chrome-Issue-992914-Sealed-Frozen-Element-Kind-Type-Confusion-RCE-Exploit/tree/master/chrome_992914)
- [V8 dev Blog : "Fast properties in V8"](https://v8.dev/blog/fast-properties)