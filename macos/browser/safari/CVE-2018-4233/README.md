# CVE-2018-4233 : Webkit Proxy Object Type Confusion Vulnerability

Webkit의 DFG JIT이 ```Proxy``` Object를 고려하지 않았기 때문에, 
```CreateThis``` operation이 실행되는 도중 임의의 Javascript 코드를 실행할 수 있고, 이를 통해 type confusion 취약점을 유발시킬 수 있다.

* Version : Safari 11.0.3 on macOS 10.13.3

## How to Exploit

Web server를 구동시킨 후, Safari 브라우저를 통해 주어진 `index.html`을 방문하게 되면 `calc`를 실행하는 exploit이 실행된다.


## Root Cause Analysis

### Patch

* Patch commit : https://github.com/WebKit/webkit/commit/b602e9d167b2c53ed96a42ed3ee611d237f5461a

* vulnerable code : https://github.com/WebKit/webkit/blob/7996e60888558ca8640cade6b1c0d6688b53ebc4/Source/JavaScriptCore/dfg/DFGAbstractInterpreterInlines.h#L2259

* patched code : https://github.com/WebKit/webkit/blob/b602e9d167b2c53ed96a42ed3ee611d237f5461a/Source/JavaScriptCore/dfg/DFGAbstractInterpreterInlines.h#L2259


### Root Cause Analysis

본 절에서는 CVE-2018-4233 취약점의 root cause 이해를 위해 필요한 배경지식 및 root cause에 대해 설명한다.

JavascriptCore는 DFG라는 graph-based IL(Intermediate Language)을 사용한다(자세한 내용은 아래의 Backgrounds 참조).

JIT 컴파일이 시작되면, 컴파일러는 모든 instruction의 side-effect를 계산하고, redundant guards를 제거하는 작업을 수행한다(`AbstractInterpreter`에 의해 수행).

* redundant guards : 중복되는 structure/type 검증 루틴을 의미한다. JIT 컴파일러는 이를 제거함으로써 실행하는 코드의 속도를 향상시킬 수 있다.
* side-effect : allowing to change structure/type of an Object.

여기서 중요한 점은 JIT 컴파일을 수행할 때, 각각의 DFG operation이 side-effect free하다는 것을 정확하게 분석해야만 한다는 것인데(program state 형태로 표현), 이를 위해 `AbstractInterpreter`는 각각의 DFG IL operation에 대해 `executeEffects` 함수를 통해 side-effect가 발생할 가능성이 있는  DFG opertation과 parameter에 `clobberWorld()` 함수를 활용하여 현재 state를 변경하게 된다.

```C++
template<typename AbstractStateType>
bool AbstractInterpreter<AbstractStateType>::executeEffects(unsigned clobberLimit, Node* node)
{
    verifyEdges(node);
    
    m_state.createValueForNode(node);
    
    switch (node->op()) {
    case JSConstant:
    case DoubleConstant:
    case Int52Constant: {
        setBuiltInConstant(node, *node->constant());
        break;
    }
            ...
            ...
    case FilterPutByIdStatus: {
        AbstractValue& value = forNode(node->child1());
        if (value.m_structure.isFinite())
            node->putByIdStatus()->filter(value.m_structure.toStructureSet());
        break;
    }

    default:
        RELEASE_ASSERT_NOT_REACHED();
        break;
    }
}

```

참고 : https://www.zerodayinitiative.com/blog/2018/4/12/inverting-your-assumptions-a-guide-to-jit-comparisons

* `clobberWorld` : This function notifies current operation is effectful

```C++
template<typename AbstractStateType>
void AbstractInterpreter<AbstractStateType>::clobberWorld()
{
    clobberStructures();
}
    
    ...
    
template<typename AbstractStateType>
void AbstractInterpreter<AbstractStateType>::clobberStructures()
{
    m_state.clobberStructures();
    m_state.mergeClobberState(AbstractInterpreterClobberState::ClobberedStructures);
    m_state.setStructureClobberState(StructuresAreClobbered);
}
```



CVE-2018-4233 취약점의 root cause가 발생하는 함수는 `AbstractInterpreter<AbstractStateType>::executeEffects`이다. 해당 함수의 `Createthis` case는 constructor가 새로운 오브젝트를 형성하는 경우에 생성되는 DFG operation으로서 다음과 같은 구조이다.

```C++
template<typename AbstractStateType>
bool AbstractInterpreter<AbstractStateType>::executeEffects(unsigned clobberLimit, Node* node)
{
                ...
                ...
    case CreateThis: {
        if (JSValue base = forNode(node->child1()).m_value) {
            if (auto* function = jsDynamicCast<JSFunction*>(m_vm, base)) {
                if (FunctionRareData* rareData = function->rareData()) {
                    if (Structure* structure = rareData->objectAllocationStructure()) {
                        // FIXME: we should be able to allocate a poly proto object here:
                        // https://bugs.webkit.org/show_bug.cgi?id=177517
                        if (structure->hasMonoProto()) {
                            m_graph.freeze(rareData);
                            m_graph.watchpoints().addLazily(rareData->allocationProfileWatchpointSet());
                            m_state.setFoundConstants(true);
                            forNode(node).set(m_graph, structure);
                            break;
                        }
                    }
                }
            }
        }
        forNode(node).setType(m_graph, SpecFinalObject);
        break;
    }
                ...
                ...
}
```
https://github.com/WebKit/webkit/blob/master/Source/JavaScriptCore/dfg/DFGAbstractInterpreterInlines.h#L2715

여기서 `clobberWorld()`가 존재하지 않음은 `Createthis` DFG operation에는 side-effect가 없다고 JIT 컴파일러가 인식했다는 의미이다.
다시 말해, ```Createthis```가 수행될 때는 별도의 type check(JSC의 [```JSC::Structure```](https://github.com/WebKit/webkit/blob/master/Source/JavaScriptCore/runtime/Structure.h) class에 해당 - v8의 경우 ```v8::Map```)를 수행하지 않음을 의미한다.

하지만, 공격자는 ```Createthis```가 수행되는 동안 임의의 Javascript 코드를 실행시킬 수 있는데(즉, side-effect가 존재), ```Createthis```가 실행될 때, constructor의 ```.prototype``` property를 설정해야 하는데, 그러한 과정에서 constructor가 JS builtin 오브젝트 ```Proxy```이고 해당 오브젝트의 ```get(target, prop)```에 대한 handler가 등록되어있다면 임의의 JS code를 실행시킬 수 있게 된다. 그 예시는 다음과 같다.

```JS
function C() {
    this.x = 42;
};

let handler = {
        get(target, prop) {
        console.log("Callback!");
        return target[prop];
    }
};

let PC = new Proxy(C, handler);

new PC();
// Callback!
```

본 취약점이 발생하는 구체적인 원인을 다음과 같이 설명할 수 있다.

```Foo``` 함수를 다음과 같이 정의하면, JSC에 의해 형성되는 DFG IR은 다음과 같다.

* function ```Foo```
```Javascript
function Foo(arg){
    this.x = arg[0];
}
```

* DFG for ```Foo```
```
DFG for Foo:
    v0 = CreateThis
    StructureCheck a0, 0x12.. // expected JSC::Structure : 0x12..
    v1 = LoadElem a0, 0
    StoreProp v0, v1, 'x'
```

여기서 컴파일러는 check hoisting을 통해 ```StructureCheck```을 DFG의 처음에도 추가하게 된다.

```
DFG for Foo:
    StructureCheck a0, 0x12.. 
    v0 = CreateThis
    StructureCheck a0, 0x12.. 
    v1 = LoadElem a0, 0
    StoreProp v0, v1, 'x'
```

마지막으로, JIT compiler의 redundancy elimination을 통해, 중앙의 ```StructureCheck``` operation을 제거하게 된다.
 
```
DFG for Foo:
    StructureCheck a0, 0x12.. 
    v0 = CreateThis
    v1 = LoadElem a0, 0
    StoreProp v0, v1, 'x'
```

즉, ```CreateThis```와 ```LoadElem``` operation 사이에 아무런 type check가 존재하지 않게 되고, 공격자는 ```Proxy```에 handler를 등록함으로써 임의의 JS 코드를 실행시켜 type confusion을 유발할 수 있다.



## Backgrounds

### Background : JSObject Internals

Javascript 언어는 모든 데이터를 오브젝트의 형태로 관리한다. 이를 JSObject라 일컫는데, JSObject는 ```property```라는 개념을 가지고 있다. ```property```는 이름과 실질적인 변수 데이터를 가지는데, 주류 브라우저들의 Javascript Engine들은 JSObject의 property name과 실질적인 property value들을 분리해서 저장한다(효율성을 위해). 이를 통해, 모든 JSObject에 type 정보를 가지게 하는 것이 아닌, 이를 공유하게 함으로써 엔진의 효율성을 향상시킬 수 있다. 예를 들어 다음 코드의 경우,

```JS
var p1 = { x: 0x41, y: 0x42 };
```

효율성을 위해, property name(```'x'```, ```'y'```)과 property value(```0x41```, ```0x42```)를 분리하여 저장한다. 이러한 property name을 분리 저장하는 자료구조는 브라우저마다 각각 다르다(v8 - `v8::Map`, JSC - `JSC::Structure`)

* example of `v8::Map`






### Background : JSC JIT Compilers [5]

JSC JIT 컴파일러의 구조는 다음과 같이 크게 4-tier로 구성되어 있다.

* Webkit JSC JIT Compiler Execution Tiers

1. the LLInt interpreter : the regular JavaScript interpreter ```LowLevelInterpreter.cpp```

```C++
// The llint C++ interpreter loop:
// LowLevelInteroreter.cpp

JSValue Cloop::execute(OpcodeID entry OpcodeID, void* executableAddress, 
VM* vm, ProtoCallFrame* protoCallFrame, bool isInitializationPass)
{
    // Loop Javascript bytecode and execute each instruction
    // [...] snip
}
```

2. the Baseline JIT compiler : 특정 함수가 빈번하게 호출되면, 해당 함수는 "hot" 상태에 돌입하게 된다. 여기서 "hot"은 특정 함수가 매우 많이 호출되어 Javascript engine이 이를 JIT 컴파일을 결정한다는 의미의 용어이다. 관련 소스는 [```JIT.cpp```](https://github.com/WebKit/webkit/blob/master/Source/JavaScriptCore/jit/JIT.cpp#L179)에 나타나 있다. 

* `JIT.cpp`

```C++
void JIT::privateCompileMainPass()
{
    if (JITInternal::verbose)
        dataLog("Compiling ", *m_codeBlock, "\n");
    
    jitAssertTagsInPlace();
    jitAssertArgumentCountSane();
    
    auto& instructions = m_codeBlock->instructions();
    unsigned instructionCount = m_codeBlock->instructions().size();

    m_callLinkInfoIndex = 0;

    VM& vm = m_codeBlock->vm();
    BytecodeIndex startBytecodeIndex(0);
    if (m_loopOSREntryBytecodeIndex && (m_codeBlock->inherits<ProgramCodeBlock>(vm) || m_codeBlock->inherits<ModuleProgramCodeBlock>(vm))) {
        // We can only do this optimization because we execute ProgramCodeBlock's exactly once.
        // This optimization would be invalid otherwise. When the LLInt determines it wants to
        // do OSR entry into the baseline JIT in a loop, it will pass in the bytecode offset it
        // was executing at when it kicked off our compilation. We only need to compile code for
        // anything reachable from that bytecode offset.

        // We only bother building the bytecode graph if it could save time and executable
        // memory. We pick an arbitrary offset where we deem this is profitable.
        if (m_loopOSREntryBytecodeIndex.offset() >= 200) {
            // As a simplification, we don't find all bytecode ranges that are unreachable.
            // Instead, we just find the minimum bytecode offset that is reachable, and
            // compile code from that bytecode offset onwards.

            BytecodeGraph graph(m_codeBlock, m_codeBlock->instructions());
            BytecodeBasicBlock* block = graph.findBasicBlockForBytecodeOffset(m_loopOSREntryBytecodeIndex.offset());
            RELEASE_ASSERT(block);

            GraphNodeWorklist<BytecodeBasicBlock*> worklist;
            startBytecodeIndex = BytecodeIndex();
            worklist.push(block);

            while (BytecodeBasicBlock* block = worklist.pop()) {
                startBytecodeIndex = BytecodeIndex(std::min(startBytecodeIndex.offset(), block->leaderOffset()));
                worklist.pushAll(block->successors());

                // Also add catch blocks for bytecodes that throw.
                if (m_codeBlock->numberOfExceptionHandlers()) {
                    for (unsigned bytecodeOffset = block->leaderOffset(); bytecodeOffset < block->leaderOffset() + block->totalLength();) {
                        auto instruction = instructions.at(bytecodeOffset);
                        if (auto* handler = m_codeBlock->handlerForBytecodeIndex(BytecodeIndex(bytecodeOffset)))
                            worklist.push(graph.findBasicBlockWithLeaderOffset(handler->target));

                        bytecodeOffset += instruction->size();
                    }
                }
            }
        }
    }
    ...
    ... 
}
```

위 함수에서 OSR(On-Stack Replacement)이라는 용어가 사용되는데, OSR은 동일 함수에 대한 서로 다른 구현을 switch한다는 의미이다. OSR의 주된 쓰임에 대해선 다음과 같은 설명을 덧붙일 수 있다.

> OSR is useful in situations where you identify a function as "hot" while it is running. This might not necessarily be because the function gets called frequently; it might be called only once, but it spends a lot of time in a big loop which could benefit from optimization. When OSR occurs, the VM is paused, and the stack frame for the target function is replaced by an equivalent frame which may have variables in different locations.


3. the DFG JIT : 

> The first execution of any function always starts in the interpreter tier. As soon as any statement in the function executes more than 100 times, or the function is called more than 6 times (whichever comes first), execution is diverted into code compiled by the Baseline JIT. This eliminates some of the interpreter’s overhead but lacks any serious compiler optimizations. Once any statement executes more than 1000 times in Baseline code, or the Baseline function is invoked more than 66 times, we divert execution again, to the DFG JIT.

DFG JIT의 생성은 자바스크립트 바이트코드를 DFG CPS 형태로 변환하는 것으로 시작한다.

* CPS (Continuous-Passing Style) : return statement를 사용하지 않고, 다음 함수를 실행시키는 형태

4. the FTL (Faster Than Light) JIT : 

The DFG JIT optimization pipeline - https://webkit.org/blog/3362/introducing-the-webkit-ftl-jit/


----

## Reference

[1] BlackHat '18 - Attacking Client Side JIT Compilers : 
https://saelo.github.io/presentations/blackhat_us_18_attacking_client_side_jit_compilers.pdf

[2] Setup and Debug JavaScriptCore : 
https://liveoverflow.com/setup-and-debug-javascriptcore-webkit-browser-0x01/

[3] Exploiting Logic Bugs in JavaScript JIT Engines : 
http://www.phrack.org/papers/jit_exploitation.html

[4] JSC Structure.h : 
https://github.com/WebKit/webkit/blob/master/Source/JavaScriptCore/runtime/Structure.h

[5] Just-in-time Compiler in JavaScriptCore - browser 0x03 : 
https://liveoverflow.com/just-in-time-compiler-in-javascriptcore-browser-0x03/

[6] JSC JIT.cpp : 
https://github.com/WebKit/webkit/blob/master/Source/JavaScriptCore/jit/JIT.cpp

[7] DFGAbstractInterpreterInlines.h : 
https://github.com/WebKit/webkit/blob/master/Source/JavaScriptCore/dfg/DFGAbstractInterpreterInlines.h

[8] Just-in-time Compiler in JavaScriptCore (WebKit) : 
https://www.youtube.com/watch?v=45wMEIIPsPA&vl=tr


[9] clobberWorld() : 
https://github.com/WebKit/webkit/blob/master/Source/JavaScriptCore/dfg/DFGAbstractInterpreterInlines.h#L4250

[10] `AbstractInterpreter<AbstractStateType>::executeEffects` : 
https://github.com/WebKit/webkit/blob/master/Source/JavaScriptCore/dfg/DFGAbstractInterpreterInlines.h#L339


[11] INVERTING YOUR ASSUMPTIONS: A GUIDE TO JIT COMPARISONS : 
https://www.zerodayinitiative.com/blog/2018/4/12/inverting-your-assumptions-a-guide-to-jit-comparisons
